(define buf #f)
(define colors #f)
(define cur #f)
(define cur-save #f)
(define color #f)
(define max (* 80 24))

(define bold? #f)

(define check? #f)

(define (term-init)
  (set! buf (make-byte-vector max 0))
  (set! colors (make-byte-vector max 0))
  (set! cur 0)
  (set! color 100))

(define (num->color n)
  (case n
    ((0)  'black)
    ((1)  'red)
    ((2)  'green)
    ((3)  'brown)
    ((4)  'blue)
    ((5)  'magenta)
    ((6)  'cyan)
    ((7)  'gray)
    ((9)  'orange)
    ((10) 'bright-green)
    ((11) 'yellow)
    ((12) 'bright-blue)
    ((13) 'bright-magenta)
    ((14) 'bright-cyan)
    ((15) 'white)
    (else 'pukish-turquoise)))

(define (buf-char i)
  (let ((n (byte-vector-ref buf i)))
    (if (< n 32)
	#\space
	(ascii->char n))))

(define (square-char-dir dir)
  (square-char (map + (get-coord) dir)))

(define (square-char coord)
  (buf-char (coord->i coord)))

(define (square-color-dir dir)
  (square-color (map + (get-coord) dir)))

(define (square-color coord)
  (num->color (map-bv-ref colors coord)))

(define (iterate-screen f seed)
  (let loop ((i 0)
	     (s seed))
    (if (= i (* 22 80))
	s
	(loop (+ i 1)
	      (f s
		 (i->coord i)
		 (let ((c (byte-vector-ref buf i)))
		   (if (< c 32)
		       #\space
		       (ascii->char c)))
		 (num->color (byte-vector-ref colors i)))))))

(define (get-row-plaintext y)
  (let ((str (make-string 80))
	(pos (* (- y 1) 80)))
    (do ((i 0 (+ i 1)))
	((= i 80))
      (string-set! str i (buf-char (+ pos i))))
    str))

(define (term-match-string? str coord)
  (let ((end (- 81 (cadr coord)))
	(pos (coord->i coord)))
    (let loop ((i 0))
      (or (> i end)
	  (and (char=? (string-ref str i)
		       (buf-char (+ pos i)))
	       (loop (+ i 1)))))))

(define (get-coord)
  (i->coord cur))

(define (inc!)
  (if (< cur max)
      (set! cur (+ cur 1))))

(define (insert-char c)
  (if (or (< (char->ascii c) 32)
	  (= (char->ascii c) 127))
      (begin
	(display "term: printing control character: ")
	(write (char->ascii c))
	(newline)))
  (byte-vector-set! buf cur (char->ascii c))
  (byte-vector-set! colors cur (if bold? (+ color 8) color))
  (inc!))

(define (limit-coord coord)
  (let ((x (car coord))
	(y (cadr coord)))
    (list (if (> x 80) 80 (if (< x 1) 1 x))
	  (if (> y 24) 24 (if (< y 1) 1 y)))))

(define (term-draw)
  (define (line)
    (display (apply string (make-list 82 #\-)))
    (newline))
  (line)
  (do ((y 1 (+ y 1)))
      ((> y 24))
    (display "|")
    (do ((x 1 (+ x 1)))
	((> x 80))
      (display (square-char (list x y))))
    (display "|")
    (newline))
  (line))

(define (term-process str)
  (define (char->num ch) (- (char->ascii ch) 48))
  (define (goto c) (set! cur (coord->i (limit-coord c))))
  (define (move n m cntl)
    (let ((n (or n 1))
	  (coord (i->coord cur))
	  (dir (cond
		((char=? cntl #\A) '(0 -1))
		((char=? cntl #\B) '(0 1))
		((char=? cntl #\C) '(1 0))
		((char=? cntl #\D) '(-1 0)))))
      (goto (map + coord (map (specialize * n) dir)))))
  (define (moveln n m cntl)
    (let ((n (or n 1))
	  (x (car (i->coord cur)))
	  (y (cadr (i->coord cur)))
	  (op (if (char=? cntl #\E) + -)))
      (goto (list x (op y n)))))
  (define (moveto n m cntl)
    (let ((y (or n 1))
	  (x (or m 1)))
      (goto (list x y))))
  (define (remember n m cntl)
    (set! cur-save cur))
  (define (restore n m cntl)
    (if cur-save
	(set! cur cur-save)))
  (let ((handlers
	 (list
	  (list #\A move) (list #\B move) (list #\C move) (list #\D move)
	  (list #\E moveln) (list #\F moveln)
	  (list #\G (lambda (n m cntl)
		      (goto (list n (cadr (i->coord cur))))))
	  (list #\H moveto) (list #\f moveto)
	  (list #\J (lambda (n m cntl)
		      (let ((x (modulo cur 80)))
			(cond ((or (not n) (zero? n))
			       (do ((i cur (+ i 1)))
				   ((= i max))
				 (byte-vector-set! buf i 0)))
			      ((= n 1)
			       (do ((i 0 (+ 1)))
				   ((> i cur))
				 (byte-vector-set! buf i 0)))
			      ((= n 2)
			       (set! buf (make-byte-vector max 0)))))))
	  (list #\K (lambda (n m cntl)
		      (let ((x (modulo cur 80)))
			(cond ((or (not n) (zero? n))
			       (do ((i 0 (+ i 1)))
				   ((> i (- 79 x)))
				 (byte-vector-set! buf (+ cur i) 0)))
			      ((= n 1)
			       (do ((i 0 (+ i 1)))
				   ((> i x))
				 (byte-vector-set! buf (- cur i) 0)))
			      ((= n 2)
			       (let ((y (quotient cur 80)))
				 (do ((i 0 (+ i 1)))
				     ((> i 79))
				   (byte-vector-set! buf (+ y i) 0))))))))
;	  (list #\S (lambda (n m cntl)
;		      (let ((n (or n 1))
;			    (new (make-byte-vector max 0)))
;			(do ((i (* n 80) (+ i 1))
;			     (j 0 (+ j 1)))
;			    ((> i max))
;			  (byte-vector-set! new j (byte-vector-ref buf i)))
;			(set! buf new))))
;	  (list #\T (lambda (n m cntl)
;		      (let ((n (or n 1))
;			    (new (make-byte-vector max 0)))
;			(do ((i 0 (+ i 1))
;			     (j (* n 80) (+ j 1)))
;			    ((> j max))
;			  (byte-vector-set! new j (byte-vector-ref buf i)))
;			(set! buf new))))
	  (list #\s remember) (list #\7 remember)
	  (list #\u restore) (list #\8 restore)))
	(len (string-length str))
	(i 0)
	(c #f))
    (call/cc
     (lambda (exit)
       (let ((next
	      (lambda ()
		(if (>= i len) (exit))
		(begin (set! c (string-ref str i))
		       (set! i (+ i 1))
		       c))))
	 (let loop ()
	   (if (not (char=? (next) #\escape))
	       (cond ((or (char=? c #\newline)
			  (= (char->ascii c) 13))
		      (set! cur (* 80 (+ 1 (quotient cur 80)))))
		     ((= (char->ascii c) 8) ; backspace
		      (if (not (zero? (modulo cur 80)))
			  (set! cur (- cur 1))))
		     (else
		      (insert-char c)))
	       (if (not (char=? (next) #\[))
		   (insert-char c)
		   (let loop ((acc #f)
			      (ls '()))
		     (cond ((char-numeric? (next))
			    (loop (+ (char->num c) (* (or acc 0) 10)) ls))
			   ((char=? c #\;)
			    (loop #f (cons acc ls)))
			   (else
			    (set! ls (reverse (if acc (cons acc ls) ls)))
			    (cond ((char=? c #\m) ; colors
				   (if (null? ls)
				       (begin (set! color 100)
					      (set! bold? #f))
				       (for-each
					(lambda (n)
					  (cond ((zero? n)
						 (set! color 100)
						 (set! bold? #f))
						((= n 1)
						 (set! bold? #t))
						((and (>= n 30) (<= n 39))
						 (set! color (- n 30)))))
					ls)))
				  ((char=? c #\?) (loop #f '()))
				  (else
				   (if (> (length ls) 2)
				       (display "Term: too many parameters\n"))
				   (let ((r (assv c handlers)))
				     (if (not r)
					 (begin
					   (display "Term: unknown escape code: ")
					   (display c)
					   (display ", with params ")
					   (write ls)
					   (newline))
					 ((cadr r)
				       (and (>= (length ls) 1) (car ls))
				       (and (>= (length ls) 2) (cadr ls))
				       c))))))))))
	   (loop)))))))
    